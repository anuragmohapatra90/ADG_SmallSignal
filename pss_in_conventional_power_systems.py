# -*- coding: utf-8 -*-
"""PSS in Conventional Power Systems.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WvZ15dSUwWguqt-BzHy5KczV8Ovbrqxf
"""

# ==============================================================================
# CHECKPOINT 1: ENVIRONMENT SETUP & PLOTTING HELPERS
# ==============================================================================
# In this section, we import necessary libraries and define the plotting logic.

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import signal
from scipy.optimize import fsolve

# --- Global Configuration Constants ---
FREQ_BASE = 50.0
W_B = 2 * np.pi * FREQ_BASE
PSS_WASH = 10.0
PSS_LAG = 0.05

# Tuning Configuration
GAIN_MARKERS = [10, 20, 30, 50, 75]
GAIN_SEARCH = [0.1, 10, 20, 30, 50, 75]
T1_SEARCH = [0.1, 0.2, 0.3, 0.4, 0.5]

# --- Helper Function: Clean Transfer Function Printing ---
def print_tf(name, num, den):
    """Helper to print Transfer Functions cleanly"""
    print(f"\n--- {name} ---")
    # Clean small numerical noise
    num = np.where(np.abs(num) < 1e-10, 0, num)
    den = np.where(np.abs(den) < 1e-10, 0, den)

    # Format string
    s_num = " + ".join([f"{c:.4f}s^{len(num)-i-1}" for i, c in enumerate(num) if abs(c) > 1e-6])
    s_den = " + ".join([f"{c:.4f}s^{len(den)-i-1}" for i, c in enumerate(den) if abs(c) > 1e-6])

    print(f"Numerator:   {s_num}")
    print(f"Denominator: {s_den}")
    print("-" * 40)

# --- Helper Function: Plotting Logic ---
def plot_time_domain(t, y, title, fig_num, color):
    plt.figure(fig_num, figsize=(12, 5))
    plt.suptitle(title, fontsize=14, fontweight='bold')

    Pe0, Vt0, w0 = 0.8, 1.0, 1.0
    offsets = [Pe0, Vt0, w0]
    titles = ["Active Power (pu)", "Terminal Voltage (pu)", "Rotor Speed (pu)"]
    ylabels = ["Pe", "Vt", "w"]

    for i in range(3):
        plt.subplot(1, 3, i+1)
        plt.plot(t, y[:, i] + offsets[i], color=color, linewidth=1.5)
        plt.title(titles[i])
        plt.xlabel("Time (s)")
        plt.ylabel(ylabels[i])
        plt.grid(True, alpha=0.3)
    plt.tight_layout()

def plot_eigenvalues(A, state_names, title, fig_num):
    vals, right_vecs = np.linalg.eig(A)

    # Sort by frequency
    idx = np.argsort(np.abs(vals.imag))
    vals = vals[idx]
    right_vecs = right_vecs[:, idx]

    # Calculate Participation Factors
    try:
        left_vecs = np.linalg.inv(right_vecs)
        P = np.abs(right_vecs * left_vecs.T).T
    except:
        P = np.zeros((len(vals), len(state_names)))

    fig = plt.figure(fig_num, figsize=(14, 6))
    fig.suptitle(title, fontsize=14, fontweight='bold')

    # 1. Complex Plane
    ax1 = plt.subplot(1, 2, 1)
    ax1.axvline(0, color='black', linewidth=1)
    ax1.axhline(0, color='gray', linewidth=0.5, linestyle=':')
    ax1.grid(True, linestyle='--', alpha=0.4)

    stable = vals.real <= 0
    ax1.scatter(vals.real[stable], vals.imag[stable], c='green', label='Stable')
    ax1.scatter(vals.real[~stable], vals.imag[~stable], c='red', marker='*', s=150, label='Unstable')
    ax1.legend()
    ax1.set_xlabel("Real Part")
    ax1.set_ylabel("Imag Part")

    # 2. Participation Table
    ax2 = plt.subplot(1, 2, 2)
    ax2.axis('off')

    row_lbls = [f"{abs(v.imag)/(2*np.pi):.2f}Hz" if abs(v.imag)>0.1 else "Static" for v in vals]
    cell_text = []
    for i in range(len(vals)):
        row = []
        for j in range(len(state_names)):
            val = P[i, j]
            row.append(f"*{val:.2f}*" if val > 0.25 else "" if val < 0.01 else f"{val:.2f}")
        cell_text.append(row)

    tbl = ax2.table(cellText=cell_text, rowLabels=row_lbls, colLabels=state_names, loc='center')
    tbl.auto_set_font_size(False); tbl.set_fontsize(8); tbl.scale(1, 1.5)
    plt.tight_layout()

def plot_root_locus(sys_open, user_gains, T1, T2, Tw, augment_func):
    print("Calculating Root Locus Sweep (0 -> 100)...")
    sweep_gains = np.linspace(0, 100, 500)
    roots_real, roots_imag = [], []

    # 1. Sweep
    for k in sweep_gains:
        sys = augment_func(sys_open, k, T1, T2, Tw)
        vals = np.linalg.eigvals(sys.A)
        roots_real.extend(vals.real)
        roots_imag.extend(vals.imag)

    # 2. Key Points
    sys_inf = augment_func(sys_open, 2000, T1, T2, Tw)
    vals_inf = np.linalg.eigvals(sys_inf.A)
    sys_zero = augment_func(sys_open, 0, T1, T2, Tw)
    vals_zero = np.linalg.eigvals(sys_zero.A)

    def draw_rl_content(ax, title):
        ax.set_title(title, fontsize=12, fontweight='bold')
        ax.axvline(0, color='black', linewidth=1)
        ax.axhline(0, color='gray', linewidth=0.5, linestyle=':')
        ax.grid(True, linestyle='--', alpha=0.4)
        ax.scatter(roots_real, roots_imag, c='gray', s=1, alpha=0.5, label='Trajectory')
        ax.scatter(vals_zero.real, vals_zero.imag, marker='x', color='black', s=60, label='Open Loop')
        ax.scatter(vals_inf.real, vals_inf.imag, marker='^', color='purple', s=60, label='K -> Inf')

        colors = plt.cm.viridis(np.linspace(0, 1, len(user_gains)))
        for i, k in enumerate(user_gains):
            sys = augment_func(sys_open, k, T1, T2, Tw)
            vals = np.linalg.eigvals(sys.A)
            # Annotate generator mode
            gen_mode = next((v for v in vals if 5 < v.imag < 15), None)
            ax.scatter(vals.real, vals.imag, color=colors[i], s=40, zorder=5)
            if gen_mode:
                ax.annotate(f"K={k}", (gen_mode.real, gen_mode.imag), xytext=(5,5),
                            textcoords='offset points', fontsize=8, color=colors[i], fontweight='bold')
        ax.set_xlabel("Real Part"); ax.set_ylabel("Imag Part")

    fig1 = plt.figure(figsize=(10, 8))
    draw_rl_content(fig1.add_subplot(111), f"Root Locus: Full Spectrum (T1={T1}s)")

    fig2 = plt.figure(figsize=(10, 8))
    ax2 = fig2.add_subplot(111)
    draw_rl_content(ax2, f"Root Locus: Zoomed View (Electromechanical Modes)")
    ax2.set_xlim(-10, 2); ax2.set_ylim(-15, 15)
    plt.show()

print("Checkpoint 1 Complete: Environment configured.")

r"""We define the power system using a 4th-order Generator Model, an Excitation System (AVR), and a Turbine Governor.

1. Non-Linear Differential Equations $f(x, u)$:$$\dot{\delta} = \omega_b (\omega - 1)$$$$\dot{\omega} = \frac{1}{2H} \left[ P_m - P_e - D(\omega - 1) \right]$$$$\dot{E}'_q = \frac{1}{T'_{do}} \left[ E_{fd} - E'_q - (X_d - X'_{d}) I_d \right]$$$$\dot{E}'_d = \frac{1}{T'_{qo}} \left[ -E'_d + (X_q - X'_{q}) I_q \right]$$

The AVR Equation (Note the $V_{pss}$ term): The Automatic Voltage Regulator (AVR) controls the field voltage. It has a main reference input ($V_{ref}$) and an auxiliary input ($V_{pss}$) for the stabilizer.$$\dot{V}_r = \frac{1}{T_a} \left[ K_a (V_{ref} + \mathbf{V_{pss}} - V_t - V_f) - V_r \right]$$Note: In the open-loop plant, we set $V_{pss} = 0$. However, we must include it as an input variable now so we have a connection point for the PSS later.$$\dot{E}_{fd} = \frac{1}{T_e} \left[ V_r - K_e E_{fd} \right]$$$$\dot{V}_f = \frac{1}{T_f} \left[ -V_f + K_f \dot{E}_{fd} \right]$$$$\dot{g} = \frac{1}{T_g} \left[ P_{ref} - g - \frac{1}{R}(\omega - 1) \right]$$$$\dot{x}_t = \frac{2}{T_w} \left[ g - x_t \right]$$

2. Linearized State-Space Model:We linearize the system around the equilibrium point $(x_0, u_0)$ to obtain the form:$$\Delta \dot{x} = A \Delta x + B \Delta u$$$$\Delta y = C \Delta x + D \Delta u$$The State Vector ($x$), Input Vector ($u$), and Output Vector ($y$) are:$$x = \begin{bmatrix} \Delta \delta & \Delta \omega & \Delta E'_q & \Delta E'_d & \Delta V_r & \Delta E_{fd} & \Delta V_f & \Delta g & \Delta x_t \end{bmatrix}^T$$$$u = \begin{bmatrix} \Delta P_{ref} & \Delta V_{ref} & \mathbf{\Delta V_{pss}} \end{bmatrix}^T$$$$y = \begin{bmatrix} \Delta P_e & \Delta V_t & \Delta \omega \end{bmatrix}^T$$The Jacobian Matrices are calculated as:$$A = \frac{\partial f}{\partial x}\bigg|_{0} \quad (\text{System Matrix, } 9 \times 9)$$$$B = \frac{\partial f}{\partial u}\bigg|_{0} \quad (\text{Input Matrix, } 9 \times 3)$$$$C = \frac{\partial y}{\partial x}\bigg|_{0} \quad (\text{Output Matrix, } 3 \times 9)$$$$D = \frac{\partial y}{\partial u}\bigg|_{0} \quad (\text{Feedthrough Matrix, } 3 \times 3)$$
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy import signal
from scipy.optimize import fsolve

# ==============================================================================
# CHECKPOINT 2 CODE: LINEARIZATION
# ==============================================================================

class LinearizedPowerSystem:
    def __init__(self):
        # Generator (4th Order) parameters
        self.H, self.D = 3.5, 0.0
        self.w_b = W_B
        self.Rs, self.Xd, self.Xq = 0.0, 1.81, 1.76
        self.Xdp, self.Xqp = 0.30, 0.65
        self.Tdo_p, self.Tqo_p = 8.00, 0.03

        # Network parameters
        self.Re, self.Xe, self.V_inf = 0.0, 0.65, 1.0

        # AVR parameters
        self.Ka, self.Ta = 50.0, 0.05
        self.Ke, self.Te = 1.0, 0.50
        self.Kf, self.Tf = 0.05, 0.50

        # Turbine parameters
        self.R, self.Tg, self.Tw = 0.05, 0.2, 1.0

        # Pre-calc Network Admittance
        self.A_net = np.array([
            [self.Re + self.Rs, -(self.Xe + self.Xqp)],
            [self.Xe + self.Xdp, self.Re + self.Rs]
        ])
        self.Y_net_inv = np.linalg.inv(self.A_net)

    def network_equations(self, delta, Ed_p, Eq_p):
        """Solves algebraic constraints (network currents/voltages)"""
        b1 = Ed_p - self.V_inf * np.sin(delta)
        b2 = Eq_p - self.V_inf * np.cos(delta)
        I = self.Y_net_inv @ np.array([b1, b2])
        Id, Iq = I[0], I[1]
        Vd = Ed_p - self.Rs * Id + self.Xqp * Iq
        Vq = Eq_p - self.Rs * Iq - self.Xdp * Id
        Vt = np.sqrt(Vd**2 + Vq**2)
        Pe = Vd * Id + Vq * Iq
        return Id, Iq, Vd, Vq, Vt, Pe

    def state_derivatives(self, x, u):
        """Standard ODE form: dx/dt = f(x, u)"""
        # x: [delta, w, Eq', Ed', Vr, Efd, Vf, g, xt]
        # u: [P_ref, V_ref, V_pss]
        delta, w, Eq_p, Ed_p, Vr, Efd, Vf, g, xt = x
        P_ref, V_ref, V_pss = u

        Id, Iq, Vd, Vq, Vt, Pe = self.network_equations(delta, Ed_p, Eq_p)
        Pm = -2*g + 3*xt

        # --- THE DIFFERENTIAL EQUATIONS (Matches LaTeX above) ---
        d_delta = self.w_b * (w - 1.0)
        d_w     = (1.0 / (2 * self.H)) * (Pm - Pe - self.D * (w - 1.0))
        d_Eq_p  = (1.0 / self.Tdo_p) * (Efd - Eq_p - (self.Xd - self.Xdp) * Id)
        d_Ed_p  = (1.0 / self.Tqo_p) * (-Ed_p + (self.Xq - self.Xqp) * Iq)
        d_Vr    = (1.0 / self.Ta) * (self.Ka * (V_ref + V_pss - Vt - Vf) - Vr)
        d_Efd   = (1.0 / self.Te) * (Vr - self.Ke * Efd)
        d_Vf    = (1.0 / self.Tf) * (-Vf + self.Kf * d_Efd)
        d_g     = (1.0 / self.Tg) * (P_ref - g - (1.0 / self.R) * (w - 1.0))
        d_xt    = (2.0 / self.Tw) * (g - xt)

        return np.array([d_delta, d_w, d_Eq_p, d_Ed_p, d_Vr, d_Efd, d_Vf, d_g, d_xt])

    def get_outputs(self, x, u):
        # Output vector: [Pe, Vt, w]
        delta, w, Eq_p, Ed_p, _, _, _, _, _ = x
        _, _, _, _, Vt, Pe = self.network_equations(delta, Ed_p, Eq_p)
        return np.array([Pe, Vt, w])

    def build_linear_model(self, P0, V0):
        """Finds equilibrium and calculates Jacobian Matrices A, B, C, D"""
        # 1. Find Equilibrium (Solve f(x)=0)
        def resid(vars):
            delta, Eq_p, Ed_p, Efd, g = vars
            Id, Iq, Vd, Vq, Vt, Pe = self.network_equations(delta, Ed_p, Eq_p)
            Pm = g
            return [Pe - P0, Vt - V0,
                    Efd - Eq_p - (self.Xd - self.Xdp) * Id,
                    -Ed_p + (self.Xq - self.Xqp) * Iq,
                    Pm - Pe]

        root = fsolve(resid, [0.5, 1.1, 0.0, 1.5, P0])
        delta0, Eq_p0, Ed_p0, Efd0, g0 = root

        # Initial State Vector
        x0 = np.array([delta0, 1.0, Eq_p0, Ed_p0, self.Ke*Efd0, Efd0, 0.0, g0, g0])
        # Initial Input Vector (V_pss = 0)
        u0 = np.array([g0, V0 + self.Ke*Efd0/self.Ka, 0.0])

        # 2. Linearize via Finite Differences
        n_x, n_u = len(x0), len(u0)
        A, B = np.zeros((n_x, n_x)), np.zeros((n_x, n_u))
        C, D = np.zeros((3, n_x)), np.zeros((3, n_u))

        eps = 1e-5
        f0 = self.state_derivatives(x0, u0)
        g0_out = self.get_outputs(x0, u0)

        for i in range(n_x):
            xp = x0.copy(); xp[i] += eps
            A[:, i] = (self.state_derivatives(xp, u0) - f0)/eps
            C[:, i] = (self.get_outputs(xp, u0) - g0_out)/eps
        for i in range(n_u):
            up = u0.copy(); up[i] += eps
            B[:, i] = (self.state_derivatives(x0, up) - f0)/eps
            D[:, i] = (self.get_outputs(x0, up) - g0_out)/eps

        return A, B, C, D

# --- Instantiate and Display the Linear Model ---
model = LinearizedPowerSystem()
A, B, C, D = model.build_linear_model(P0=0.8, V0=1.0)

# Define labels for display
state_names = ["Delta", "Omega", "Eq'", "Ed'", "Vr", "Efd", "Vf", "Gate", "Turb_x"]
input_names = ["P_ref", "V_ref", "V_pss"]
output_names = ["Pe", "Vt", "Omega"]

print("\n=== LINEARIZED SYSTEM MATRICES (A, B, C) ===")
print("\n[A] State Matrix (9x9):")
print(pd.DataFrame(A, index=state_names, columns=state_names).to_string())

print("\n[B] Input Matrix (9x3):")
print(pd.DataFrame(B, index=state_names, columns=input_names).to_string())

print("\n[C] Output Matrix (3x9):")
print(pd.DataFrame(C, index=output_names, columns=state_names).to_string())

# ==============================================================================
# CHECKPOINT 3: SIMULATION WITHOUT PSS
# ==============================================================================
# We simulate a step response in Mechanical Power P_ref.
# Since the AVR is high-gain and there is no damping, we expect instability.

# 1. Create SciPy StateSpace object
sys_open = signal.StateSpace(A, B, C, D)

# Create a subset system (Inputs: Pref, Vref only) used for simulation without PSS
sys_no_pss = signal.StateSpace(A, B[:, 0:1], C, D[:, 0:1])

# 2. Define Input Signal (Step at T=2s)
t = np.linspace(0, 30, 2000)
u = np.zeros_like(t)
u[t >= 2.0] = 0.1

# 3. Simulation
print("Running Case 1: No PSS...")
t1, y1, _ = signal.lsim(sys_no_pss, u, t)

# 4. Visualization
plot_time_domain(t1, y1, "Response: NO PSS (Step at t=2s)", 1, 'red')
plt.show() # Show the first plot

plot_eigenvalues(sys_open.A, state_names, "Stability: NO PSS", 2)
plt.show() # Show the second plot

r"""In this section, we design the Power System Stabilizer (PSS) to add damping to the electromechanical oscillations.

1. The PSS Transfer Function:
The PSS takes the rotor speed deviation ($\Delta \omega$) as input and provides a voltage signal ($V_{pss}$) to the AVR.$$V_{pss}(s) = K_{pss} \cdot \underbrace{\left( \frac{sT_w}{1+sT_w} \right)}_{\text{Washout}} \cdot \underbrace{\left( \frac{1+sT_1}{1+sT_2} \right)^2}_{\text{Lead-Lag}} \cdot \Delta \omega(s)$$

Washout Filter: Removes DC offsets so the PSS only acts during transients.

Lead-Lag Blocks: Compensate for the phase lag introduced by the excitation system, ensuring the torque produced is in phase with speed changes (pure damping).

2. Conversion to State-Space ($A_{pss}, B_{pss}, C_{pss}, D_{pss}$):
We convert this Transfer Function into a state-space model with 3 states ($x_{pss}$): one for the washout and two for the lead-lag blocks.$$\dot{x}_{pss} = A_{pss} x_{pss} + B_{pss} u_{pss}$$$$y_{pss} = C_{pss} x_{pss} + D_{pss} u_{pss}$$Where input $u_{pss} = \Delta \omega$ (from the Plant) and output $y_{pss} = V_{pss}$ (to the Plant).

3. System Augmentation (The "Big" Matrix):We combine the Generator (Plant) and the PSS into one large closed-loop system.

Plant State: $\dot{x}_p = A_p x_p + B_p u$

PSS State: $\dot{x}_{pss} = A_{pss} x_{pss} + B_{pss} (C_{p, \omega} x_p)$

Substituting the coupling equations creates the Augmented State Matrix ($A_{new}$):$$A_{new} =
\begin{bmatrix}
A_p + B_{p, Vpss} D_{pss} C_{p, \omega} & B_{p, Vpss} C_{pss} \\
B_{pss} C_{p, \omega} & A_{pss}
\end{bmatrix}$$

Top Left: Original plant modified by PSS direct feedthrough.

Top Right: Effect of PSS states on the Plant.

Bottom Left: Effect of Plant speed output on PSS states.

Bottom Right: Internal PSS dynamics.

The total system size increases from 9 states to **12 states.**
"""

# ==============================================================================
# CHECKPOINT 4 CODE: PSS IMPLEMENTATION & INSPECTION
# ==============================================================================

def create_pss_transfer_function(K, T1, T2, Tw):
    """
    Returns the StateSpace representation of the PSS.
    V_pss(s) = K * [sTw/(1+sTw)] * [(1+sT1)/(1+sT2)]^2 * dw(s)
    """
    # 1. Washout: sTw / (1 + sTw)
    num_w = np.array([Tw, 0.0])
    den_w = np.array([Tw, 1.0])

    # 2. Lead-Lag: (1 + sT1) / (1 + sT2)
    num_ll = np.array([T1, 1.0])
    den_ll = np.array([T2, 1.0])

    # 3. Combine: Washout * LeadLag * LeadLag (Convolution = Multiplication in s-domain)
    num_total = signal.convolve(num_w, num_ll)
    den_total = signal.convolve(den_w, den_ll)

    # Second stage LeadLag
    num_total = signal.convolve(num_total, num_ll)
    den_total = signal.convolve(den_total, den_ll)

    # Apply Gain
    tf = signal.TransferFunction(K * num_total, den_total)

    # Convert to State Space (A_pss, B_pss, C_pss, D_pss)
    return signal.StateSpace(tf)

def augment_system_with_pss(sys_open_loop, K, T1, T2, Tw):
    """
    Connects the PSS State Space to the Open Loop System.
    Input:  sys_open_loop (9 states)
    Output: sys_closed_loop (12 states)
    """
    sys_pss = create_pss_transfer_function(K, T1, T2, Tw)

    A_p, B_p, C_p, D_p = sys_open_loop.A, sys_open_loop.B, sys_open_loop.C, sys_open_loop.D
    A_s, B_s, C_s, D_s = sys_pss.A, sys_pss.B, sys_pss.C, sys_pss.D

    # --- MAPPING CONNECTIONS ---
    # 1. Plant Output (Source): Rotor Speed 'w' is at index 2 of C_p
    # y_w = C_p[2, :] * x_p
    C_w = C_p[2:3, :]

    # 2. Plant Input (Destination): V_pss is at index 2 of B_p
    # The PSS output acts on the 3rd input channel of the plant
    B_vpss = B_p[:, 2:3]
    D_vpss = D_p[:, 2:3] # Feedthrough from V_pss input to Plant Outputs

    # --- AUGMENTATION MATH (Block Matrices) ---
    # New State Vector x_new = [x_plant, x_pss]^T

    # Top-Left: Ap + (Link: B_vpss -> D_pss -> C_w)
    TL = A_p + B_vpss @ D_s @ C_w

    # Top-Right: Effect of PSS states on Plant (Link: B_vpss -> C_pss)
    TR = B_vpss @ C_s

    # Bottom-Left: Effect of Plant states on PSS (Link: B_pss -> C_w)
    BL = B_s @ C_w

    # Bottom-Right: Internal PSS dynamics
    BR = A_s

    A_new = np.block([[TL, TR], [BL, BR]])

    # Augmented B Matrix: We only keep external inputs (P_ref, V_ref)
    # V_pss is now internal, so we drop column 2 of B_p
    B_ext = B_p[:, 0:2]
    B_new = np.block([
        [B_ext],
        [np.zeros((A_s.shape[0], 2))] # PSS doesn't see P_ref/V_ref directly
    ])

    # Augmented C Matrix: We want to see [Pe, Vt, w]
    # y = Cp*xp + Dp*u. Since u[2] comes from PSS, we add feedthrough
    C_new = np.block([
        [C_p + D_vpss @ D_s @ C_w, D_vpss @ C_s]
    ])

    # Augmented D Matrix: Feedthrough from [Pref, Vref] to outputs
    D_new = D_p[:, 0:2]

    return signal.StateSpace(A_new, B_new, C_new, D_new)

def tune_pss_parameters(sys_open_loop, gain_range, t1_range, Tw, T2):
    """Grid search to find K and T1 that maximize damping."""
    best_damping = 1e9
    best_params = (0, 0)
    best_sys = None

    print(f"Tuning PSS over {len(gain_range)*len(t1_range)} combinations...")

    for k in gain_range:
        for t1 in t1_range:
            sys_cand = augment_system_with_pss(sys_open_loop, k, t1, T2, Tw)
            vals = np.linalg.eigvals(sys_cand.A)
            max_real = np.max(vals.real)

            if max_real < best_damping:
                best_damping = max_real
                best_params = (k, t1)
                best_sys = sys_cand

    return best_sys, best_params

# --- INSPECTION BLOCK ---
# Let's create a dummy PSS to see what the math did
test_pss_sys = augment_system_with_pss(sys_open, K=10, T1=0.2, T2=0.05, Tw=10.0)

print("\n=== SYSTEM AUGMENTATION REPORT ===")
print(f"Original Plant States: {sys_open.A.shape[0]} states")
print(f"PSS Controller States: 3 states (1 Washout + 2 Lead-Lag)")
print(f"Augmented System:      {test_pss_sys.A.shape[0]} states")
print("-" * 40)
print(f"Original A Matrix Shape: {sys_open.A.shape}")
print(f"Augmented A Matrix Shape: {test_pss_sys.A.shape}")
print("Note: The new 12x12 matrix contains the coupled dynamics.")
print("==================================")

# Define augmented state and input names for display
pss_state_names = ["Pss_w", "Pss_ll1", "Pss_ll2"]
augmented_state_names = state_names + pss_state_names
augmented_input_names = ["P_ref", "V_ref"] # V_pss is now internal

# Display A, B, C matrices for the AUGMENTED system
print("\n=== AUGMENTED SYSTEM MATRICES (A_new, B_new, C_new) ===")
print("\n[A_new] State Matrix (12x12):")
print(pd.DataFrame(test_pss_sys.A, index=augmented_state_names, columns=augmented_state_names).to_string())

print("\n[B_new] Input Matrix (12x2):")
print(pd.DataFrame(test_pss_sys.B, index=augmented_state_names, columns=augmented_input_names).to_string())

print("\n[C_new] Output Matrix (3x12):")
print(pd.DataFrame(test_pss_sys.C, index=output_names, columns=augmented_state_names).to_string())

# ==============================================================================
# CHECKPOINT 5: TUNING, SIMULATION & ROOT LOCUS
# ==============================================================================

print("\nRunning Case 2: With PSS...")

# 1. Tune PSS
sys_pss_closed, params = tune_pss_parameters(
    sys_open, GAIN_SEARCH, T1_SEARCH, Tw=PSS_WASH, T2=PSS_LAG
)
best_k, best_t1 = params
print(f"Optimal Parameters Found: K={best_k}, T1={best_t1}s")

# Create a 2D input signal for lsim (2 inputs: P_ref, V_ref)
u_lsim = np.zeros((len(t), 2))
u_lsim[t >= 2.0, 0] = 0.1 # Step in P_ref

# 2. Simulate Step Response with Tuned PSS
t2, y2, _ = signal.lsim(sys_pss_closed, u_lsim, t)

# 3. Plot Time Domain and Eigenvalues
plot_time_domain(t2, y2, f"Response: WITH PSS (K={best_k}, Step at t=2s)", 3, 'green')

pss_states = state_names + ["PSS_WO", "PSS_LL1", "PSS_LL2"]
plot_eigenvalues(sys_pss_closed.A, pss_states, "Stability: WITH PSS", 4)

# 4. Plot Root Locus
plot_root_locus(
     sys_open, GAIN_MARKERS, best_t1, PSS_LAG, PSS_WASH, augment_system_with_pss
)

# 5. Print Transfer Functions
print("\n" + "="*60)
print("                  SYSTEM TRANSFER FUNCTIONS")
print("="*60)

# Get PSS Transfer Function
pss_ss_only = create_pss_transfer_function(best_k, best_t1, PSS_LAG, PSS_WASH)
num_pss, den_pss = signal.ss2tf(pss_ss_only.A, pss_ss_only.B, pss_ss_only.C, pss_ss_only.D)
print_tf(f"PSS Controller (K={best_k}, T1={best_t1})", num_pss.flatten(), den_pss.flatten())

# Get Plant Transfer Function (V_pss -> Omega)
# Note: Input index 2 of original system is V_pss
num_plant, den_plant = signal.ss2tf(sys_open.A, sys_open.B, sys_open.C, sys_open.D, input=2)
# Output index 2 is Omega
print_tf("Power System Plant (V_pss -> Omega)", num_plant[2], den_plant)

print("="*60 + "\n")
plt.show()