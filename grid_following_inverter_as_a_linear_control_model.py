# -*- coding: utf-8 -*-
"""Grid following inverter as a linear control model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P0T9v6_iEkUsYLRtjbDdhXiItuSeqbTv
"""

# ==============================================================================
# CHECKPOINT 1: ENVIRONMENT & PLOTTING UTILITIES
# ==============================================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal
from scipy.optimize import fsolve

# --- Plotting Functions ---
def plot_time_domain(t, y, title, color, style='-'):
    """Standard time domain plotter for Current and Power"""
    # y indices: 0=i2d, 1=i2q, 2=P, 3=Q
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    fig.suptitle(title, fontsize=14, fontweight='bold')

    # 1. Currents (Grid Side)
    ax1.plot(t, y[:, 0], color=color, linestyle=style, label=r'$i_{2d}$')
    ax1.plot(t, y[:, 1], color='orange', linestyle=style, label=r'$i_{2q}$')
    ax1.set_title("Grid Currents (dq-frame)")
    ax1.set_ylabel("Current (A)")
    ax1.set_xlabel("Time (s)")
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # 2. Power
    ax2.plot(t, y[:, 2]/1000.0, color=color, linestyle=style, label='P (kW)')
    ax2.plot(t, y[:, 3]/1000.0, color='red', linestyle='--', label='Q (kVar)')
    ax2.set_title("Inverter Output Power")
    ax2.set_ylabel("Power (kW/kVar)")
    ax2.set_xlabel("Time (s)")
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    plt.tight_layout()

def plot_eigenvalue_map(A_list, labels, colors):
    """Compare poles of different damping strategies"""
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_title("Root Locus: Passive vs Active Damping", fontsize=14, fontweight='bold')
    ax.axvline(0, color='k', lw=1)
    ax.axhline(0, color='gray', ls=':', lw=0.5)

    for A, lbl, c in zip(A_list, labels, colors):
        vals = np.linalg.eigvals(A)
        # Filter high frequency LCL modes for clearer view if needed,
        # but showing all helps visualize the resonance damping.
        ax.scatter(vals.real, vals.imag, color=c, label=lbl, s=60, alpha=0.7)

    ax.grid(True, linestyle='--', alpha=0.4)
    ax.set_xlabel("Real Part (Stability)")
    ax.set_ylabel("Imaginary Part (Oscillation Freq)")
    ax.set_xlim(-2000, 200) # Zoom in on relevant area
    ax.set_ylim(-10000, 10000)
    ax.legend()
    plt.show()

print("Checkpoint 1 Complete: Environment Configured.")

r"""We model a Grid Following Inverter (GFL) connected via an LCL Filter. The system is modeled in the Synchronous Reference Frame ($dq$-frame).

1. LCL Filter PhysicsThe filter connects the inverter output ($v_{inv}$) to the grid voltage ($v_g$).

Inverter Side Inductor ($L_1$):$$\frac{d i_{1d}}{dt} = \frac{1}{L_1} (v_{inv,d} - v_{cd} - R_1 i_{1d}) + \omega i_{1q}$$$$\frac{d i_{1q}}{dt} = \frac{1}{L_1} (v_{inv,q} - v_{cq} - R_1 i_{1q}) - \omega i_{1d}$$Filter Capacitor ($C_f$):$$\frac{d v_{cd}}{dt} = \frac{1}{C_f} (i_{1d} - i_{2d}) + \omega v_{cq}$$$$\frac{d v_{cq}}{dt} = \frac{1}{C_f} (i_{1q} - i_{2q}) - \omega v_{cd}$$Grid Side Inductor ($L_2$):$$\frac{d i_{2d}}{dt} = \frac{1}{L_2} (v_{cd} - v_{gd} - R_2 i_{2d}) + \omega i_{2q}$$$$\frac{d i_{2q}}{dt} = \frac{1}{L_2} (v_{cq} - v_{gq} - R_2 i_{2q}) - \omega i_{2d}$$

2. Phase Locked Loop (PLL)The PLL estimates the grid angle $\delta$ to keep $v_{gq} \approx 0$.$$\dot{\delta} = \omega_{pll} - \omega_g$$$$\dot{x}_{pll} = K_{i,pll} v_{cq}$$$$\omega_{pll} = \omega_g + K_{p,pll} v_{cq} + x_{pll}$$

3. Outer Power ControlPI controllers regulate Active ($P$) and Reactive ($Q$) power to generate current references ($i_{ref}$).$$\dot{\zeta}_d = K_{i,p} (P_{set} - P_{meas})$$$$\dot{\zeta}_q = K_{i,p} (Q_{set} - Q_{meas})$$$$i_{1d,ref} = K_{p,p} (P_{set} - P_{meas}) + \zeta_d$$

4. Inner Current ControlPI controllers regulate the inverter current $i_1$ to track $i_{ref}$.$$\dot{\gamma}_d = K_{i,c} (i_{1d,ref} - i_{1d})$$$$\dot{\gamma}_q = K_{i,c} (i_{1q,ref} - i_{1q})$$$$v_{inv,d}^* = K_{p,c}(i_{err}) + \gamma_d + \text{Decoupling}$$

5. PWM Delay (Neglected)In this model, we assume the switching frequency (e.g., 20 kHz) is infinite compared to our simulation timescale. Thus, we assume the average voltage applied is exactly the commanded voltage:$$v_{inv} \approx v_{inv}^*$$
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal
from scipy.optimize import fsolve

# --- Plotting Functions ---
def plot_time_domain(t, y, title, color, style='-'):
    """Standard time domain plotter for Current and Power"""
    # y indices: 0=i2d, 1=i2q, 2=P, 3=Q
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))
    fig.suptitle(title, fontsize=14, fontweight='bold')

    # 1. Currents (Grid Side)
    ax1.plot(t, y[:, 0], color=color, linestyle=style, label=r'$i_{2d}$'
)
    ax1.plot(t, y[:, 1], color='orange', linestyle=style, label=r'$i_{2q}$'
)
    ax1.set_title("Grid Currents (dq-frame)")
    ax1.set_ylabel("Current (A)")
    ax1.set_xlabel("Time (s)")
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # 2. Power
    ax2.plot(t, y[:, 2]/1000.0, color=color, linestyle=style, label='P (kW)'
)
    ax2.plot(t, y[:, 3]/1000.0, color='red', linestyle='--', label='Q (kVar)'
)
    ax2.set_title("Inverter Output Power")
    ax2.set_ylabel("Power (kW/kVar)")
    ax2.set_xlabel("Time (s)")
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    plt.tight_layout(h_pad=2.0) # Added h_pad for more vertical spacing

def plot_eigenvalue_map(A_list, labels, colors):
    """Compare poles of different damping strategies"""
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.set_title("Root Locus: Passive vs Active Damping", fontsize=14, fontweight='bold')
    ax.axvline(0, color='k', lw=1)
    ax.axhline(0, color='gray', ls=':', lw=0.5)

    for A, lbl, c in zip(A_list, labels, colors):
        vals = np.linalg.eigvals(A)
        # Filter high frequency LCL modes for clearer view if needed,
        # but showing all helps visualize the resonance damping.
        ax.scatter(vals.real, vals.imag, color=c, label=lbl, s=60, alpha=0.7)

    ax.grid(True, linestyle='--', alpha=0.4)
    ax.set_xlabel("Real Part (Stability)")
    ax.set_ylabel("Imaginary Part (Oscillation Freq)")
    ax.set_xlim(-2000, 200) # Zoom in on relevant area
    ax.set_ylim(-10000, 10000)
    ax.legend()
    plt.show()

print("Checkpoint 1 Complete: Environment Configured.")

# ==============================================================================
# CHECKPOINT 2 CODE: MODEL DEFINITION & MATRIX VISUALIZATION
# ==============================================================================

# System Constants
P_BASE = 50e3
V_BASE = 400.0
F_BASE = 50.0
W_BASE = 2 * np.pi * F_BASE

Z_BASE = V_BASE**2 / P_BASE
L_BASE = Z_BASE / W_BASE
C_BASE = 1.0 / (Z_BASE * W_BASE)

class GridFollowingInverter:
    def __init__(self):
        # --- 1. LCL Filter Physics ---
        self.L1 = 0.05 * L_BASE
        self.R1 = 0.001 * Z_BASE # Initial: Low parasitic resistance
        self.Cf = 0.05 * C_BASE
        self.L2 = 0.02 * L_BASE
        self.R2 = 0.001 * Z_BASE
        self.w_g = W_BASE

        # --- 2. Control Gains ---
        self.Kp_pll, self.Ki_pll = 0.5, 50.0   # PLL
        self.Kp_c,   self.Ki_c   = 2.0, 100.0  # Current Loop
        self.Kp_p,   self.Ki_p   = 0.005, 5.0  # Power Loop

        # Active Damping Gain (Initially OFF)
        self.K_active = 0.0

        # Setpoints
        self.P_set = 0.8 * P_BASE
        self.Q_set = 0.0
        self.Vg_dq = np.array([np.sqrt(2/3)*V_BASE, 0.0])

    def set_passive_damping(self, r_pu):
        """Changes physical resistors R1/R2"""
        self.R1 = r_pu * Z_BASE
        self.R2 = r_pu * Z_BASE

    def set_active_damping(self, k_pu):
        """Changes Virtual Resistor gain"""
        self.K_active = k_pu * Z_BASE

    def equations(self, x, u=None):
        i1_d, i1_q = x[0], x[1]
        vc_d, vc_q = x[2], x[3]
        i2_d, i2_q = x[4], x[5]
        delta      = x[6]
        x_pll      = x[7]
        gamma_d, gamma_q = x[8], x[9]
        zeta_d,  zeta_q  = x[10], x[11]

        P_ref_perturb = u[0] if u is not None else 0.0
        vg_d, vg_q = self.Vg_dq

        # --- PLL & Transforms ---
        sin_d, cos_d = np.sin(delta), np.cos(delta)

        # Measure Capacitor Voltage for PLL
        vc_d_c =  vc_d * cos_d + vc_q * sin_d
        vc_q_c = -vc_d * sin_d + vc_q * cos_d

        # Transform Currents
        i1_d_c = i1_d * cos_d + i1_q * sin_d
        i1_q_c = -i1_d * sin_d + i1_q * cos_d
        i2_d_c = i2_d * cos_d + i2_q * sin_d
        i2_q_c = -i2_d * sin_d + i2_q * cos_d

        # Capacitor Current (for Active Damping)
        ic_d_c = i1_d_c - i2_d_c
        ic_q_c = i1_q_c - i2_q_c

        # PLL Dynamics
        w_pll = self.w_g + self.Kp_pll * vc_q_c + x_pll
        d_delta = w_pll - self.w_g
        d_x_pll = self.Ki_pll * vc_q_c

        # --- CONTROL LOOPS ---
        # Power Loop
        P_ctrl = 1.5 * (vc_d_c * i1_d_c + vc_q_c * i1_q_c)
        Q_ctrl = 1.5 * (vc_q_c * i1_d_c - vc_d_c * i1_q_c)
        err_P = (self.P_set + P_ref_perturb) - P_ctrl
        err_Q = self.Q_set - Q_ctrl

        i1_d_ref = self.Kp_p * err_P + zeta_d
        i1_q_ref = -(self.Kp_p * err_Q + zeta_q)
        d_zeta_d, d_zeta_q = self.Ki_p * err_P, self.Ki_p * err_Q

        # Current Loop
        err_id = i1_d_ref - i1_d_c
        err_iq = i1_q_ref - i1_q_c

        v_pi_d = self.Kp_c * err_id + gamma_d - self.w_g * self.L1 * i1_q_c + vc_d_c
        v_pi_q = self.Kp_c * err_iq + gamma_q + self.w_g * self.L1 * i1_d_c + vc_q_c
        d_gamma_d, d_gamma_q = self.Ki_c * err_id, self.Ki_c * err_iq

        # --- ACTIVE DAMPING INJECTION ---
        # v_inv = v_control - K_active * i_capacitor
        v_inv_d_c = v_pi_d - self.K_active * ic_d_c
        v_inv_q_c = v_pi_q - self.K_active * ic_q_c

        v_inv_d = v_inv_d_c * cos_d - v_inv_q_c * sin_d
        v_inv_q = v_inv_d_c * sin_d + v_inv_q_c * cos_d

        # --- LCL PHYSICS ---
        w = self.w_g
        d_i1_d = (v_inv_d - vc_d - self.R1*i1_d)/self.L1 + w*i1_q
        d_i1_q = (v_inv_q - vc_q - self.R1*i1_q)/self.L1 - w*i1_d
        d_vc_d = (i1_d - i2_d)/self.Cf + w*vc_q
        d_vc_q = (i1_q - i2_q)/self.Cf - w*vc_d
        d_i2_d = (vc_d - vg_d - self.R2*i2_d)/self.L2 + w*i2_q
        d_i2_q = (vc_q - vg_q - self.R2*i2_q)/self.L2 - w*i2_d

        return np.array([d_i1_d, d_i1_q, d_vc_d, d_vc_q, d_i2_d, d_i2_q,
                         d_delta, d_x_pll, d_gamma_d, d_gamma_q, d_zeta_d, d_zeta_q])

    def output_equations(self, x, u=None):
        i2_d, i2_q = x[4], x[5]
        vc_d, vc_q = x[2], x[3]
        P_phys = 1.5 * (vc_d * i2_d + vc_q * i2_q)
        Q_phys = 1.5 * (vc_q * i2_d - vc_d * i2_q)
        return np.array([i2_d, i2_q, P_phys, Q_phys])

    def calculate_power_loss(self, x):
        """Calculates Ohmic losses in LCL filter"""
        i1_d, i1_q = x[0], x[1]
        i2_d, i2_q = x[4], x[5]
        # Power Loss = 1.5 * R * (id^2 + iq^2)
        loss_R1 = 1.5 * self.R1 * (i1_d**2 + i1_q**2)
        loss_R2 = 1.5 * self.R2 * (i2_d**2 + i2_q**2)
        return loss_R1 + loss_R2

    def get_linearized_model(self):
        u0 = np.array([0.0])
        # Equilibrium Search
        x0_guess = np.zeros(12)
        x0_guess[2] = self.Vg_dq[0]
        x0_guess[0] = self.P_set / (1.5 * self.Vg_dq[0])
        func_eq = lambda x: self.equations(x, u0)
        x0 = fsolve(func_eq, x0_guess)

        # Linearization
        n_x, n_u = len(x0), 1
        A, B = np.zeros((n_x, n_x)), np.zeros((n_x, n_u))
        C, D = np.zeros((4, n_x)), np.zeros((4, n_u))
        eps = 1e-5
        f0 = self.equations(x0, u0)
        g0 = self.output_equations(x0, u0)

        for i in range(n_x):
            xp = x0.copy(); xp[i] += eps
            A[:, i] = (self.equations(xp, u0) - f0)/eps
            C[:, i] = (self.output_equations(xp, u0) - g0)/eps
        for i in range(n_u):
            up = u0.copy(); up[i] += eps
            B[:, i] = (self.equations(x0, up) - f0)/eps
            D[:, i] = (self.output_equations(x0, up) - g0)/eps

        return A, B, C, D, x0

# --- INITIALIZE AND DISPLAY MATRICES ---
gfl = GridFollowingInverter()
A, B, C, D, x0 = gfl.get_linearized_model()

state_names = ["i1d", "i1q", "vcd", "vcq", "i2d", "i2q", "delta", "x_pll", "gam_d", "gam_q", "zet_d", "zet_q"]
input_names = ["P_ref_step"]
output_names = ["i2d", "i2q", "P", "Q"]

print("\n=== LINEARIZED GFL MATRICES (A, B, C) ===")
print("\n[A] State Matrix (12x12) - Interaction of LCL resonance and Controllers:")
print(pd.DataFrame(A, index=state_names, columns=state_names).to_string())

print("\n[B] Input Matrix (12x1):")
print(pd.DataFrame(B, index=state_names, columns=input_names).to_string())

print("\n[C] Output Matrix (4x12):")
print(pd.DataFrame(C, index=output_names, columns=state_names).to_string())

r"""We will now simulate the system using "High-Efficiency" parameters.

Resistors ($R_1, R_2$): Set to very low values ($0.005$ pu). In the real world, we want these low to minimize heat and maximize power transfer to the grid.

Active Damping: Turned OFF for now, as we want to test the baseline performance of our standard PI controllers.

We apply a 5kW Step Change in power reference at $t=0.05s$ and observe the response.
"""

# ==============================================================================
# CHECKPOINT 3: BASE CASE SIMULATION
# ==============================================================================

# 1. Initialize with Efficient Hardware Parameters
gfl = GridFollowingInverter()
gfl.set_passive_damping(0.005) # Only 0.5% Resistance (High Efficiency)
gfl.set_active_damping(0.0)    # OFF (Standard Control)

# 2. Linearize & Simulate
A_base, B_base, C_base, D_base, x0_base = gfl.get_linearized_model()
y0_base = gfl.output_equations(x0_base, np.array([0.0]))

sys_base = signal.StateSpace(A_base, B_base, C_base, D_base)

t = np.linspace(0, 0.2, 5000)
u_step = np.zeros_like(t)
u_step[t >= 0.05] = 5000.0 # 5kW Step Change

print("Simulating Base Case (High Efficiency Hardware)...")
_, y_base, _ = signal.lsim(sys_base, u_step, t)

# 3. Add Equilibrium Back for Plotting
y_plot_base = y_base + y0_base

# 4. Calculate Efficiency
loss_base = gfl.calculate_power_loss(x0_base)
print(f"Resistive Power Loss: {loss_base:.2f} Watts (Very low losses!)")

plot_time_domain(t, y_plot_base, "Case 1: Base Response (Low R)", 'red')
plt.show()

r"""Observation: What happened?

Instability! The system is completely unstable.

The currents are oscillating wildly and growing unbounded.Why?We have excited the LCL Filter Resonance.

The LCL filter creates a sharp resonance peak at $f_{res} = \frac{1}{2\pi}\sqrt{\frac{L_1+L_2}{L_1 L_2 C_f}}$.

Our control loops (Current and Power) and the PLL are interacting with this resonance mode.

Because our resistors ($R_1, R_2$) are so small, there is no physical damping to absorb this energy. The oscillation grows until the system (in real life) trips or explodes.

We need to fix this.

The "Hardware" Fix

The most straightforward way to damp a resonance is to add physical resistance. This is called Passive Damping.

We will physically increase the resistance of our filter inductors ($R_1, R_2$) to 8% (0.08 pu). This acts like a shock absorber for the electrical oscillations.

Hypothesis: The system should stabilize, but we might pay a penalty in efficiency.
"""

# ==============================================================================
# CHECKPOINT 4: PASSIVE DAMPING (ADDING RESISTORS)
# ==============================================================================

# 1. Increase Physical Resistance
# We intentionally degrade the hardware efficiency to gain stability
gfl.set_passive_damping(0.15) # Increase R to 15%
gfl.set_active_damping(0.0)   # Active Damping still OFF

# 2. Linearize & Simulate
A_pass, B_pass, C_pass, D_pass, x0_pass = gfl.get_linearized_model()
y0_pass = gfl.output_equations(x0_pass, np.array([0.0]))

sys_pass = signal.StateSpace(A_pass, B_pass, C_pass, D_pass)

print("Simulating Passive Damping Case...")
_, y_pass, _ = signal.lsim(sys_pass, u_step, t)
y_plot_pass = y_pass + y0_pass

# 3. Calculate Efficiency
loss_pass = gfl.calculate_power_loss(x0_pass)

# Print the Trade-off
print(f"Status: STABLE")
# Using ANSI escape codes for bold text: \033[1m (start bold) and \033[0m (end bold)
print(f"Resistive Power Loss: \033[1m{loss_pass:.2f}\033[0m Watts")
print(f"Increase in Waste Heat: \033[1m{loss_pass/loss_base:.1f}\033[0m x higher than base case!")

plot_time_domain(t, y_plot_pass, "Case 2: Passive Damping (Stable but Lossy)", 'blue')
plt.show()

r"""The "Software" Fix: Virtual Resistor

We successfully stabilized the system in Case 2, but we are wasting hundreds of Watts just to stop the oscillation.

Can we achieve the same damping without the heat loss?This is where Active Damping comes in. We modify the inverter control voltage command ($v_{inv}^*$) to mimic the behavior of a resistor.$$v_{inv}^* = v_{PI} - \mathbf{K_{active}} \cdot i_c$$

When the capacitor current ($i_c$) oscillates, the controller reduces the voltage command proportionally. This creates a "Virtual Resistance" that damps the resonance.

Since this is a calculation inside the microcontroller, it consumes zero real power.

Simulation: We revert the hardware to the high-efficiency settings ($R=0.005$) but enable the Active Damping gain.
"""

# ==============================================================================
# CHECKPOINT 5: ACTIVE DAMPING (THE SMART FIX) & ROOT LOCUS ANALYSIS
# ==============================================================================

# --- 1. SETUP MODELS ---
# A. Unstable Case (Low R, Active OFF)
gfl.set_passive_damping(0.005)
gfl.set_active_damping(0.0)
A_unstable, _, _, _, _ = gfl.get_linearized_model()

# B. Active Damping Case (Low R, Active ON)
gfl.set_active_damping(5)
A_active, B_act, C_act, D_act, x0_act = gfl.get_linearized_model()

# C. Passive Damping Case (for comparison plot)
# (We already calculated A_pass in CP4, but re-calculating to be safe if cells run out of order)
gfl.set_passive_damping(0.15)
gfl.set_active_damping(0.0)
A_pass_cmp, _, _, _, _ = gfl.get_linearized_model()

# Reset GFL to Active configuration for simulation
gfl.set_passive_damping(0.005)
gfl.set_active_damping(1.5)

# --- 2. SIMULATION (Active Damping) ---
sys_active = signal.StateSpace(A_active, B_act, C_act, D_act)
print("Simulating Active Damping Case...")
_, y_act, _ = signal.lsim(sys_active, u_step, t)

# Efficiency Check
loss_act = gfl.calculate_power_loss(x0_act)
print(f"Status: STABLE")
print(f"Resistive Power Loss: \033[1m{loss_act:.2f}\033[0m Watts (Efficient!)")

# Plot Time Domain (Standard Style)
y_plot = y_act + gfl.output_equations(x0_act, np.array([0.0]))
plot_time_domain(t, y_plot, "Case 3: Active Damping (Stable & Efficient)", 'green')
plt.show()

# --- 3. ROOT LOCUS COMPARISON (1x3 Plot) ---
def get_plot_limits(matrices):
    # Helper to ensure ALL poles (even unstable RHP ones) are visible
    all_real = []
    all_imag = []
    for A in matrices:
        vals = np.linalg.eigvals(A)
        all_real.extend(vals.real)
        all_imag.extend(vals.imag)

    # Add padding
    x_min = -5000
    x_max = max(all_real) + 3000 # Crucial for seeing Unstable poles
    y_max = max(np.abs(all_imag)) * 1.1
    return (x_min, x_max), (-y_max, y_max)

fig, axes = plt.subplots(1, 3, figsize=(18, 6), sharey=True)
fig.suptitle("Root Locus Comparison: Impact of Damping Methods", fontsize=16, fontweight='bold')

matrices = [A_unstable, A_pass_cmp, A_active]
titles = ["1. Unstable (Low R)", "2. Passive (High R)", "3. Active (Virtual R)"]
colors = ['red', 'blue', 'green']

(xlim, ylim) = get_plot_limits(matrices)

for i, ax in enumerate(axes):
    vals = np.linalg.eigvals(matrices[i])
    ax.scatter(vals.real, vals.imag, color=colors[i], s=60, alpha=0.7)

    # Visual Guides
    ax.axvline(0, color='k', lw=1.5)
    ax.axhline(0, color='gray', ls=':')

    # Highlighting Unstable Poles
    unstable = vals[vals.real > 0]
    if len(unstable) > 0:
        ax.scatter(unstable.real, unstable.imag, facecolors='none', edgecolors='red', s=150, lw=2, label='Unstable')
        ax.text(xlim[1]*0.1, ylim[1]*0.8, "UNSTABLE!", color='red', fontweight='bold')

    ax.set_title(titles[i], fontweight='bold')
    ax.set_xlabel("Real Part")
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    ax.grid(True, which='both', linestyle='--', alpha=0.4)

axes[0].set_ylabel("Imaginary Part (Hz)")
plt.tight_layout(h_pad=2.0) # Added h_pad for more vertical spacing
plt.show()

# --- 4. MIGRATION MAP (Unstable -> Active) ---
fig, ax = plt.subplots(figsize=(16, 10))
ax.set_title("Pole Migration: Origin of Instability -> Active Stabilization", fontsize=14, fontweight='bold')

v_start = np.linalg.eigvals(A_unstable)
v_end   = np.linalg.eigvals(A_active)

# Sort by frequency to match mode-to-mode
v_start = sorted(v_start, key=lambda x: x.imag)
v_end   = sorted(v_end, key=lambda x: x.imag)

# Plot Points
ax.scatter([v.real for v in v_start], [v.imag for v in v_start], c='red', marker='*', s=200, label='Origin (Unstable)', zorder=5)
ax.scatter([v.real for v in v_end], [v.imag for v in v_end], c='green', marker='o', s=100, label='Final (Active Damped)', zorder=5)

# Draw Arrows
for s, e in zip(v_start, v_end):
    # Only draw arrows for the resonance modes (large movement)
    if abs(s - e) > 50:
        ax.annotate("", xy=(e.real, e.imag), xytext=(s.real, s.imag),
                    arrowprops=dict(arrowstyle="->", color="black", alpha=0.6, lw=1.5))

# Formatting
ax.axvline(0, color='k', lw=2)
ax.axhline(0, color='gray', ls=':')
# Balance the axis limits to prevent narrow plot
# Extend x-axis to match the aspect ratio of y-axis
x_range = xlim[1] - xlim[0]
y_range = ylim[1] - ylim[0]
# Make x-axis wider to better match y-axis range
if y_range > x_range:
    # Center the x-axis and expand it proportionally
    x_center = (xlim[0] + xlim[1]) / 2
    new_x_range = y_range * 0.6  # Make x-axis 60% of y-axis range for better proportion
    ax.set_xlim(x_center - new_x_range/2, x_center + new_x_range/2)
    ax.set_ylim(ylim)
else:
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)

ax.set_xlabel("Real Part", fontsize=12)
ax.set_ylabel("Imaginary Part", fontsize=12)
ax.legend(loc='upper left', fontsize=10)
ax.grid(True, linestyle='--', alpha=0.4)

plt.tight_layout()
plt.show()