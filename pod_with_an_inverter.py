# -*- coding: utf-8 -*-
"""POD with an inverter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m70or4N8mYpvZLJKpkc47j4v1cDU_cAq
"""

# ==============================================================================
# CHECKPOINT 1: ENVIRONMENT & CONFIGURATION
# ==============================================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal
from scipy.optimize import fsolve

# --- CONFIGURATION ---
FREQ_BASE = 50.0
W_B = 2 * np.pi * FREQ_BASE

# Tuning: Search range to find optimal Lead Time Constant (T1)
LEAD_SEARCH_RANGE = [0.01, 0.05, 0.1, 0.2, 0.4]

# Gains to test (Negative = Braking Action)
GAINS_TO_TEST = [-5, -15, -30, -60, -80, -100]

# --- Helper: Plotting Style ---
def setup_plot(title, xlabel, ylabel):
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.grid(True, alpha=0.3, linestyle='--')
    return fig, ax

print("Checkpoint 1 Complete: Environment Configured.")

r"""We model a hybrid system: a conventional Synchronous Generator connected to the grid, with a Grid Forming Inverter (GFL) connected at the terminals acting as a fast actuator.

1. Synchronous Generator (4th Order):$$\dot{\delta} = \omega_b (\omega - 1)$$$$\dot{\omega} = \frac{1}{2H} (P_m - P_e - D(\omega-1))$$$$\dot{E}'_q = \frac{1}{T'_{do}} (E_{fd} - E'_q - (X_d - X'_d)I_d)$$$$\dot{E}'_d = \frac{1}{T'_{qo}} (-E'_d + (X_q - X'_q)I_q)$$

2. The Inverter Actuator (Current Injection):The inverter is modeled as a fast current source with a time constant $T_{inv}$. It injects currents $I_{d,inv}$ and $I_{q,inv}$ into the grid.$$\dot{I}_{d,inv} = \frac{1}{T_{inv}} (I_{d,ref} - I_{d,inv})$$$$\dot{I}_{q,inv} = \frac{1}{T_{inv}} (I_{q,ref} - I_{q,inv})$$

3. The Network Coupling (The "Magic"):The Generator and Inverter share the terminal voltage $V_t$. The Inverter current changes the voltage drop across the line, effectively altering the power flow of the generator.$$V_t = V_{inf} + Z_{line} (I_{gen} + I_{inv})$$
"""

# ==============================================================================
# CHECKPOINT 2 CODE: INTEGRATED PLANT MODEL
# ==============================================================================

class IntegratedPowerSystem:
    def __init__(self):
        # Generator (4th Order)
        self.H, self.D = 3.5, 0.0
        self.w_b = W_B
        self.Rs, self.Xd, self.Xq = 0.0, 1.81, 1.76
        self.Xdp, self.Xqp = 0.30, 0.65
        self.Tdo_p, self.Tqo_p = 8.00, 0.03

        # Network
        self.Re, self.Xe = 0.0, 0.65
        self.V_inf = 1.0

        # AVR & Turbine
        self.Ka, self.Ta = 50.0, 0.05
        self.Ke, self.Te = 1.0, 0.50
        self.Kf, self.Tf = 0.05, 0.50
        self.R, self.Tg, self.Tw = 0.05, 0.2, 1.0

        # Inverter Actuator (Fast Current Loop)
        self.T_inv = 0.02

    def network_solution(self, delta, Ed_p, Eq_p, Id_inv, Iq_inv):
        """Solves Vt = V_inf + Z_line * (I_gen + I_inv)"""
        # Source Voltages
        V_inf_d = self.V_inf * np.sin(delta)
        V_inf_q = self.V_inf * np.cos(delta)

        # Feedforward Voltage Drop from Inverter Current
        Vd_inj = self.Re * Id_inv - self.Xe * Iq_inv
        Vq_inj = self.Xe * Id_inv + self.Re * Iq_inv

        # Generator Z Matrix
        R_tot = self.Re + self.Rs
        A_mat = np.array([[R_tot, -(self.Xe + self.Xqp)],
                          [self.Xe + self.Xdp, R_tot]])

        # RHS
        B_vec = np.array([Ed_p - V_inf_d - Vd_inj,
                          Eq_p - V_inf_q - Vq_inj])

        I_gen = np.linalg.solve(A_mat, B_vec)
        Id, Iq = I_gen[0], I_gen[1]

        Vd = Ed_p - self.Rs * Id + self.Xqp * Iq
        Vq = Eq_p - self.Rs * Iq - self.Xdp * Id
        Vt = np.sqrt(Vd**2 + Vq**2)
        Pe = Vd * Id + Vq * Iq
        return Id, Iq, Vd, Vq, Vt, Pe

    def derivatives(self, x, u):
        delta, w, Eq_p, Ed_p, Vr, Efd, Vf, g, xt, id_inv, iq_inv = x
        P_ref, V_ref, id_inv_ref, iq_inv_ref = u

        Id, Iq, Vd, Vq, Vt, Pe = self.network_solution(delta, Ed_p, Eq_p, id_inv, iq_inv)
        Pm = -2*g + 3*xt

        # Generator Dynamics
        d_delta = self.w_b * (w - 1.0)
        d_w     = (1.0 / (2 * self.H)) * (Pm - Pe - self.D * (w - 1.0))
        d_Eq_p  = (1.0 / self.Tdo_p) * (Efd - Eq_p - (self.Xd - self.Xdp) * Id)
        d_Ed_p  = (1.0 / self.Tqo_p) * (-Ed_p + (self.Xq - self.Xqp) * Iq)
        d_Vr    = (1.0 / self.Ta) * (self.Ka * (V_ref - Vt - Vf) - Vr)
        d_Efd   = (1.0 / self.Te) * (Vr - self.Ke * Efd)
        d_Vf    = (1.0 / self.Tf) * (-Vf + self.Kf * d_Efd)
        d_g     = (1.0 / self.Tg) * (P_ref - g - (1.0 / self.R) * (w - 1.0))
        d_xt    = (2.0 / self.Tw) * (g - xt)

        # Inverter Actuator Dynamics
        d_id_inv = (id_inv_ref - id_inv) / self.T_inv
        d_iq_inv = (iq_inv_ref - iq_inv) / self.T_inv

        return np.array([d_delta, d_w, d_Eq_p, d_Ed_p, d_Vr, d_Efd, d_Vf, d_g, d_xt, d_id_inv, d_iq_inv])

    def get_outputs(self, x, u):
        delta, w, Eq_p, Ed_p, _, _, _, _, _, id_inv, iq_inv = x
        _, _, _, _, Vt, Pe = self.network_solution(delta, Ed_p, Eq_p, id_inv, iq_inv)
        return np.array([Pe, Vt, w])

    def get_linearized_plant(self):
        # 1. Equilibrium Search
        def resid(vars):
            delta, Eq_p, Ed_p, Efd, g = vars
            Id, Iq, Vd, Vq, Vt, Pe = self.network_solution(delta, Ed_p, Eq_p, 0.0, 0.0)
            Pm = g
            return [Pe - 0.8, Vt - 1.0,
                    Efd - Eq_p - (self.Xd - self.Xdp) * Id,
                    -Ed_p + (self.Xq - self.Xqp) * Iq,
                    Pm - Pe]

        root = fsolve(resid, [0.5, 1.1, 0.0, 1.5, 0.8])
        delta0, Eq_p0, Ed_p0, Efd0, g0 = root

        # State: [Gen_States (9), Inv_States (2)]
        x0 = np.array([delta0, 1.0, Eq_p0, Ed_p0, self.Ke*Efd0, Efd0, 0.0, g0, g0, 0.0, 0.0])
        u0 = np.array([g0, 1.0 + self.Ke*Efd0/self.Ka, 0.0, 0.0])

        # 2. Linearization
        n_x, n_u = len(x0), len(u0)
        A = np.zeros((n_x, n_x)); B = np.zeros((n_x, n_u))
        C = np.zeros((3, n_x));   D = np.zeros((3, n_u))
        eps = 1e-5
        f0 = self.derivatives(x0, u0)
        g0_out = self.get_outputs(x0, u0)

        for i in range(n_x):
            x_p = x0.copy(); x_p[i] += eps
            A[:, i] = (self.derivatives(x_p, u0) - f0)/eps
            C[:, i] = (self.get_outputs(x_p, u0) - g0_out)/eps
        for i in range(n_u):
            u_p = u0.copy(); u_p[i] += eps
            B[:, i] = (self.derivatives(x0, u_p) - f0)/eps
            D[:, i] = (self.get_outputs(x0, u_p) - g0_out)/eps

        return signal.StateSpace(A, B, C, D)

# --- Display Matrices ---
sys_model = IntegratedPowerSystem()
sys_plant = sys_model.get_linearized_plant()

state_names = ["Delta", "Omega", "Eq'", "Ed'", "Vr", "Efd", "Vf", "Gate", "Turb_x", "Id_inv", "Iq_inv"]
input_names = ["P_ref", "V_ref", "Id_ref", "Iq_ref"]

print("\n=== OPEN LOOP PLANT MATRICES ===")
print("\n[A] State Matrix (Note the Actuator States at the end):")
print(pd.DataFrame(sys_plant.A, index=state_names, columns=state_names).to_string())

print("\n[B] Input Matrix (Note inputs 2 and 3 control the Inverter):")
print(pd.DataFrame(sys_plant.B, index=state_names, columns=input_names).to_string())

r"""We simulate a step in mechanical power ($P_{ref}$) with no control on the Inverter ($I_{d,ref}=0$).

We verify that the generator has a natural electromechanical oscillation (Swing Mode).
"""

# ==============================================================================
# CHECKPOINT 3: BASELINE SIMULATION (NO POD)
# ==============================================================================

# 1. Setup Simulation (Step in Pref at t=2s)
t = np.linspace(0, 10, 2000)
u_ol = np.zeros((len(t), 1))
u_ol[t >= 2.0] = 0.05 # 5% Step

# 2. Extract Sub-system (Input 0 only: Pref)
sys_ol_sim = signal.StateSpace(sys_plant.A, sys_plant.B[:, 0:1], sys_plant.C[0:1], sys_plant.D[0:1, 0:1])

# 3. Simulate
_, y_ol, _ = signal.lsim(sys_ol_sim, u_ol, t)
y_ol = y_ol.flatten() + 0.8 # Add equilibrium P0

# 4. Identify Oscillation Mode
vals_ol, _ = np.linalg.eig(sys_plant.A)
mode_ol = min([v for v in vals_ol if v.imag > 5 and v.imag < 20], key=lambda x: x.real)

print(f"Dominant Oscillation Mode: {mode_ol.real:.4f} Â± j{mode_ol.imag:.4f}")
print(f"Damping Ratio: {-mode_ol.real/abs(mode_ol):.4f} (Poor)")

fig, ax = setup_plot("Baseline Response: Generator Power (No POD)", "Time (s)", "Active Power (pu)")
ax.plot(t, y_ol, 'k--', linewidth=2, label='Open Loop')
ax.legend()
plt.show()

r"""1. The Controller Structure

The POD calculates a reference current ($I_{d,ref}$) to counteract speed changes ($\Delta \omega$).$$I_{d,ref}(s) = K_{pod} \cdot \underbrace{\left( \frac{sT_w}{1+sT_w} \right)}_{\text{Washout}} \cdot \underbrace{\left( \frac{1+sT_{lead}}{1+sT_{lag}} \right)^2}_{\text{Lead-Lag}} \cdot \Delta \omega(s)$$

2. The Closed-Loop AugmentationWe merge the Plant (11 States) and the POD (3 States) into one Augmented System (14 States).

The state equations are coupled:

Plant: $\dot{x}_p = A_p x_p + B_{p,ext} u_{ext} + B_{p,ctrl} I_{d,ref}$

POD: $\dot{x}_{pod} = A_{pod} x_{pod} + B_{pod} (\Delta \omega)$

Substituting the connections ($\Delta \omega = C_{p,\omega} x_p$ and $I_{d,ref} = C_{pod} x_{pod}$), we get the Augmented Matrix $A_{cl}$:$$A_{cl} =
\begin{bmatrix}
A_p & B_{p,ctrl} C_{pod} \\
B_{pod} C_{p,\omega} & A_{pod}
\end{bmatrix}$$

(Note: If there is feedthrough $D$, additional terms appear on the diagonal, handled automatically by the code.)

Top-Right: The POD actuating the Plant.

Bottom-Left: The Plant driving the POD sensors.
"""

# ==============================================================================
# CHECKPOINT 4 CODE: POD CONTROLLER & MATRIX VISUALIZATION
# ==============================================================================

def design_pod_controller(sys_plant, K, T_lead):
    """
    POD Design: Speed (Output 2) -> Active Current Id_ref (Input 2)
    """
    Tw, T_lag = 10.0, 0.05

    # Define Polynomials
    num_w = np.array([Tw, 0.0])
    den_w = np.array([Tw, 1.0])

    num_ll = np.array([T_lead, 1.0])
    den_ll = np.array([T_lag, 1.0])

    # Cascade: Washout * LeadLag * LeadLag
    num = np.convolve(num_w, num_ll)
    den = np.convolve(den_w, den_ll)
    num = np.convolve(num, num_ll)
    den = np.convolve(den, den_ll)

    sys_pod = signal.StateSpace(signal.TransferFunction(K * num, den))

    # --- Augment Plant ---
    A_p, B_p, C_p, D_p = sys_plant.A, sys_plant.B, sys_plant.C, sys_plant.D
    A_c, B_c, C_c, D_c = sys_pod.A, sys_pod.B, sys_pod.C, sys_pod.D

    # Connections:
    # Plant Output 2 (Omega) -> POD Input
    C_w = C_p[2:3, :]
    # POD Output -> Plant Input 2 (Id_ref)
    B_t = B_p[:, 2:3]
    D_t = D_p[:, 2:3]

    # Augmented Matrices
    # A_new = [ A_p + B_t*Dc*Cw    B_t*Cc ]
    #         [ Bc*Cw              Ac     ]
    A_cl = np.block([[A_p + B_t @ D_c @ C_w, B_t @ C_c], [B_c @ C_w, A_c]])

    # Inputs: Keep external P_ref (0) and V_ref (1), drop internal control inputs
    B_cl = np.block([[B_p[:, 0:2]], [np.zeros((A_c.shape[0], 2))]])

    # Outputs: Same as plant [Pe, Vt, w] + Feedthrough effects
    C_cl = np.block([[C_p + D_t @ D_c @ C_w,  D_t @ C_c]])
    D_cl = D_p[:, 0:2]

    return signal.StateSpace(A_cl, B_cl, C_cl, D_cl)

# --- VISUALIZATION OF THE AUGMENTED SYSTEM ---

# 1. Create a Test System (K=-10, T_lead=0.1)
sys_augmented = design_pod_controller(sys_plant, K=-10, T_lead=0.1)

# 2. Define Labels
# Plant States (11) + POD States (3)
aug_state_names = state_names + ["POD_x1 (Washout)", "POD_x2 (LeadLag1)", "POD_x3 (LeadLag2)"]
aug_input_names = ["P_ref", "V_ref"] # We reduced inputs from 4 to 2 (Internalized Id/Iq)

print("\n=== CLOSED LOOP SYSTEM MATRICES (PLANT + POD) ===")
print(f"Original States: {len(state_names)} | Augmented States: {len(aug_state_names)}")

print("\n[A_cl] Augmented State Matrix (14x14):")
print("Notice the coupling in the Top-Right (Control) and Bottom-Left (Feedback) blocks:")
print(pd.DataFrame(sys_augmented.A, index=aug_state_names, columns=aug_state_names).to_string())

print("\n[B_cl] Augmented Input Matrix (14x2):")
print("Notice only P_ref and V_ref remain as external inputs:")
print(pd.DataFrame(sys_augmented.B, index=aug_state_names, columns=aug_input_names).to_string())

"""We now sweep the Gain ($K$) to see the effect of the POD.

We also analyze Power Injection to understand the physics:

Generator Power ($P_{gen}$): The mechanical oscillations we want to stop.

Inverter Power ($P_{inv}$): The energy injected/absorbed by the GFL to counteract the swing.
"""

# ==============================================================================
# CHECKPOINT 5: VARIABLE GAIN & POWER BREAKDOWN
# ==============================================================================

# 1. Find Optimal Lead Time Constant (T1)
best_damp = 1e9
best_t1 = 0.1
test_k = GAINS_TO_TEST[int(len(GAINS_TO_TEST)/2)]

for t1 in LEAD_SEARCH_RANGE:
    sys = design_pod_controller(sys_plant, test_k, t1)
    vals = np.linalg.eigvals(sys.A)
    # Find the mode closest to original oscillation
    mode_cl = min(vals, key=lambda x: abs(x.imag - mode_ol.imag))
    if mode_cl.real < best_damp:
        best_damp = mode_cl.real
        best_t1 = t1

print(f"Optimal Lead T1 found: {best_t1}s")

# 2. Setup Comparison Plots
fig1, ax1 = setup_plot("Root Locus: Variable Gain Sweep", "Real Part", "Imaginary Part")
ax1.axvline(0, color='k', linewidth=1)
fig2, ax2 = setup_plot("Step Response: Damping Effect", "Time (s)", "Active Power (pu)")

# Plot Open Loop Baseline
ax1.scatter(vals_ol.real, vals_ol.imag, c='k', marker='x', s=100, label='Open Loop', zorder=10)
ax2.plot(t, y_ol, 'k--', linewidth=2, label='No POD')

# 3. Simulation Loop
colors = plt.cm.viridis(np.linspace(0, 1, len(GAINS_TO_TEST)))
u = np.zeros((len(t), 2)); u[t >= 2.0] = 0.05

for idx, k in enumerate(GAINS_TO_TEST):
    sys = design_pod_controller(sys_plant, k, best_t1)

    # A. Root Locus
    vals = np.linalg.eigvals(sys.A)
    ax1.scatter(vals.real, vals.imag, color=colors[idx], s=40, label=f'K={k}')

    # B. Time Domain
    # We output Output 0 (Pe) for the main plot
    sys_sim = signal.StateSpace(sys.A, sys.B, sys.C[0:1], sys.D[0:1])
    _, y_cl, _ = signal.lsim(sys_sim, u, t)
    ax2.plot(t, y_cl.flatten() + 0.8, color=colors[idx], linewidth=1.5, label=f'K={k}')

ax1.legend(loc='upper left'); ax2.legend(loc='upper right')
plt.show()

# 4. POWER BREAKDOWN (Physics Analysis)
# We pick the strongest gain to see the Inverter working hard
k_strong = min(GAINS_TO_TEST)
sys_strong = design_pod_controller(sys_plant, k_strong, best_t1)

# Run simulation returning STATES to get Inverter Current
_, y_s, x_s = signal.lsim(sys_strong, u, t)

P_gen = y_s[:, 0] + 0.8
# Inverter Power is approx proportional to Id_inv (State 9)
# P_inv ~ V_term * Id_inv
P_inv = x_s[:, 9]
P_total = P_gen + P_inv

fig3, ax3 = setup_plot(f"Power Breakdown at PCC (K={k_strong})", "Time (s)", "Active Power (pu)")
ax3.plot(t, P_gen, 'r', label='Generator Power (Oscillating)')
ax3.plot(t, P_inv, 'b', label='Inverter Injection (Counter-Acting)')
ax3.plot(t, P_total, 'k--', lw=2, label='Total Grid Power (Damped)')
ax3.legend()
plt.show()